// Copyright (c) 2018 Pocketwatch Games LLC.

using UnityEngine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Collections;

#if UNITY_EDITOR
using UnityEditor;
using System.Text;
#endif

namespace Bowhead.MetaGame {
	using AbilityClass = Actors.Spells.AbilityClass;
	[Serializable]
	public sealed class InventoryItemLibrary {
		public const ulong FIRST_AUTOGRANT_ID = 1;
		public const ulong MAX_AUTOGRANT_ID = FIRST_AUTOGRANT_ID+100;

		[SerializeField]
		int _baseID;
		[SerializeField]
		DropItemClass[] _items;
		[SerializeField]
		InventoryItemClass[] _id2item;
		[SerializeField]
		int[] _id2ilvl;

		List<DropItemClass> _temp;
		Dictionary<AbilityClass, InventoryGrantAbilityItemClass> _autoGrantSpells;

		public DropItemClass GetRandomItemOfType(IList<ItemMetaClass> types, int ilvl, float p) {
			if (_temp == null) {
				_temp = new List<DropItemClass>();
			}

			for (int i = 0; i < _items.Length; ++i) {
				var item = _items[i];
				var iitem = item as InventoryItemClass;
				if ((item != null) && ((iitem == null) || !iitem.deprecated) && item.CheckiLvlRange(ilvl) && (item.metaClass != null) && item.metaClass.IsAny(types)) {
					_temp.Add(item);
				}
			}

			DropItemClass selected = null;
			if (_temp.Count > 0) {
				selected = _temp[Utils.LerpRange(0, _temp.Count, p)];				
				_temp.Clear();
			}

			return selected;
		}

		public int GetIDiLvl(int id) {
			return _id2ilvl[id - _baseID];
		}

		public bool TryGetItem(int id, out InventoryItemClass itemClass, out int ilvl) {
			id -= _baseID;
			if ((id >= 0) && (id < _id2item.Length)) {
				itemClass = _id2item[id];
				ilvl = _id2ilvl[id];
				var range = itemClass.generatedItems.ilvlRange;
				if ((ilvl >= range.x) && (ilvl <= range.y)) {
					return true;
				}
			}
			itemClass = null;
			ilvl = -1;
			return false;
		}

		public int GetAutoGrantSpellBaseiLvl(AbilityClass spell) {
			InventoryGrantAbilityItemClass itemClass;
			if (_autoGrantSpells.TryGetValue(spell, out itemClass)) {
				return itemClass.ilvlRange.x;
			}
			return 1;
		}

		public void OnAfterDeserialize() {
			IndexAutoGeneratedItems();
		}

		void IndexAutoGeneratedItems() {
			_autoGrantSpells = new Dictionary<AbilityClass, InventoryGrantAbilityItemClass>();
			for (int i = 0; i < _items.Length; ++i) {
				var item = _items[i] as InventoryGrantAbilityItemClass;
				if ((item != null) && item.autoGrant) {
					_autoGrantSpells.Add(item.abilityClass, item);
				}
			}
		}

		public IEnumerator GetEnumerator() {
			return _items.GetEnumerator();
		}

#if UNITY_EDITOR
		public static bool Index(GameManager gmInstance) {
			var library = gmInstance.staticData.inventoryItemLibrary;
			if (library != null) {
				var modified = false;

				var items = (library._items != null) ? new List<DropItemClass>(library._items) : new List<DropItemClass>();

				for (int i = 0; i < gmInstance.staticData.indexedObjects.Length; ++i) {
					var item = gmInstance.staticData.indexedObjects[i] as DropItemClass;
					if ((item != null) && !items.Contains(item)) {
						items.Add(item);
						modified = true;
					}
				}

				for (int i = items.Count-1; i >= 0; --i) {
					if (items[i] == null) {
						items.RemoveAtSwap(i);
						modified = true;
					}
				}

				if (modified) {
					library._items = items.ToArray();
				}

				modified = library.GenerateItems() || modified;
				library.IndexAutoGeneratedItems();

				return modified;
			}
			return false;
		}

		bool GenerateItems() {
			Dictionary<int, InventoryItemClass> ids = new Dictionary<int, InventoryItemClass>();
			Dictionary<int, int> ilvl = new Dictionary<int, int>();

			int nextFreeID;
			int idStart;

			LoadNextFreeID(out idStart, out nextFreeID);

			// these id's must persist and cannot be changed.
			// id (0) is considered invalid.
			for (int i = idStart; i < nextFreeID; ++i) {
				ids.Add(i, _id2item[i-_baseID]);
				ilvl.Add(i, _id2ilvl[i-_baseID]);
			}

			var nextID = nextFreeID;
			var dirty = false;

			if (_items != null) {
				// for all items, generate steam inventory id's

				for (int i = 0; i < _items.Length; ++i) {
					var item = _items[i] as InventoryItemClass;
					if (item != null) {
						item.BeginGeneratedItems();

						if (item.deprecated) {
							item.ClearIDs(idStart, nextFreeID, ids);
						} else if (item.generatedItems.ilvlStep < 1) {
							Debug.LogWarning(item.name + ": no generated ilvls (step is 0).");
							item.ClearIDs(idStart, nextFreeID, ids);
						} else {
							var generated = item.generatedItems;
							var ilvl2id = item.ilvl2id;

							bool missingIDs = false;

							for (int k = generated.ilvlRange.x; k <= generated.ilvlRange.y; k += generated.ilvlStep) {
								missingIDs = (ilvl2id == null) || !ilvl2id.ContainsKey(k);
								if (missingIDs) {
									break;
								}
							}

							missingIDs = missingIDs || (ilvl2id == null) || !ilvl2id.ContainsKey(generated.ilvlRange.y);
							missingIDs = item.ClearIDs(idStart, nextFreeID, ids) || missingIDs;

							if (missingIDs) {
								for (int k = generated.ilvlRange.x; k < generated.ilvlRange.y; k += generated.ilvlStep) {
									var id = nextID++;
									item.TryAddItemID(k, id);
									ids.Add(id, item);
									ilvl.Add(id, k);
								}

								item.TryAddItemID(generated.ilvlRange.y, nextID);
								ids.Add(nextID, item);
								ilvl.Add(nextID, generated.ilvlRange.y);
								++nextID;
								dirty = true;
							}
						}
						item.ConditionalFlushAndMarkDirty();
					}
				}

				var idsList = new List<InventoryItemClass>(nextID);
				var ilvlList = new List<int>(nextID);

				if (_baseID != idStart) {
					_baseID = idStart;
					dirty = true;
				}

				foreach (var pair in ids) {
					var id = pair.Key - _baseID;
					while (idsList.Count <= id) {
						idsList.Add(null);
					}
					idsList[id] = pair.Value;
				}

				foreach (var pair in ilvl) {
					var id = pair.Key - _baseID;
					while (ilvlList.Count <= id) {
						ilvlList.Add(-1);
					}
					ilvlList[id] = pair.Value;
				}
				
				if (!dirty) {
					if (((idsList.Count > 0) && (_id2item == null)) || ((_id2item != null) && (idsList.Count != _id2item.Length))) {
						dirty = true;
					}
					if (!dirty) {
						for (int i = 0; i < idsList.Count; ++i) {
							dirty = idsList[i] != _id2item[i];
							if (dirty) {
								break;
							}
						}
					}
				}

				if (!dirty) {
					if (((ilvlList.Count > 0) && (_id2ilvl == null)) || ((_id2ilvl != null) && (ilvlList.Count != _id2ilvl.Length))) {
						dirty = true;
					}
					if (!dirty) {
						for (int i = 0; i < ilvlList.Count; ++i) {
							dirty = ilvlList[i] != _id2ilvl[i];
							if (dirty) {
								break;
							}
						}
					}
				}

				if (dirty) {
					_baseID = idStart;
					_id2item = idsList.ToArray();
					_id2ilvl = ilvlList.ToArray();
				}
			}

			return dirty;
		}

		static void LoadNextFreeID(out int first, out int last) {
			using (var file = new StreamReader(Utils.projectRootDirectory + "/SteamInventory/nextid.txt", System.Text.Encoding.ASCII)) {
				first = int.Parse(file.ReadLine());
				last = int.Parse(file.ReadLine());
			}
		}

		static void SaveNextFreeID(int first, int last) {
			using (var file = new StreamWriter(Utils.projectRootDirectory + "/SteamInventory/nextid.txt", false, System.Text.Encoding.ASCII)) {
				file.WriteLine(first);
				file.WriteLine(last);
			}
		}

		/*
		brazilian 
		bulgarian 
		czech 
		danish 
		dutch 
		english 
		finnish 
		french 
		german 
		greek 
		hungarian 
		italian 
		japanese 
		koreana 
		norwegian 
		polish 
		portuguese 
		romanian 
		russian 
		schinese 
		spanish 
		swedish 
		tchinese 
		thai 
		turkish 
		arabic 
		ukrainian
		*/

		static string[][] _steamLangCodes = new[] {
			new [] { "pt-BR", "brazilian" },
			new [] { "bg", "bulgarian" },
			new [] { "cs", "czech" },
			new [] { "da", "danish" },
			new [] { "nl", "dutch" },
			new [] { "en", "english" },
			new [] { "fi", "finnish" },
			new [] { "fr", "french" },
			new [] { "de", "german" },
			new [] { "el", "greek" },
			new [] { "hu", "hungarian" },
			new [] { "it", "italian" },
			new [] { "ja", "japanese" },
			new [] { "ko", "koreana" },
			new [] { "no", "norwegian" },
			new [] { "pl", "polish" },
			new [] { "pt", "portuguese" },
			new [] { "ro", "romanian" },
			new [] { "ru", "russian" },
			new [] { "zh-CHS", "schinese" },
			new [] { "es", "spanish" },
			new [] { "sv", "swedish" },
			new [] { "zh-CHT", "tchinese" },
			new [] { "th", "thai" },
			new [] { "tr", "turkish" },
			new [] { "ar", "arabic" },
			new [] { "uk", "ukrainian" }
		};
		
		[MenuItem("Bowhead/Export Steam Inventory...")]
		public static void Export() {
			var upload = EditorUtility.DisplayDialog("Upload Items?", "Would you like to upload modified item definitions to steam?", "Yes", "No");
		
			Action<StringBuilder, string, string, string, string, int, float, float, float> translateFunc;
			{
				// FIXME
				/*
				SmartCultureInfoCollection languages = null;
				var resource = Resources.Load(LanguageRuntimeData.AvailableCulturesFilePath()) as TextAsset;
				if (resource != null) {
					languages = SmartCultureInfoCollection.Deserialize(resource);
				}

				var languageTable = new Dictionary<string, SortedDictionary<string, LocalizedObject>>();

				foreach (var culture in languages.cultureInfos) {
					var data = (TextAsset)Resources.Load(LanguageRuntimeData.LanguageFilePath(culture.languageCode));
					var dict = LanguageParser.LoadLanguage(data.text);
					languageTable.Add(culture.languageCode, dict);
				}
				*/
				translateFunc = (StringBuilder file, string nameKey, string descKey, string name, string itemType, int ilvl, float param1, float param2, float param3) => {
					//var itemKey = "ItemType." + itemType;

					//var english = false;
					//for (int i = 0; i < _steamLangCodes.Length; ++i) {
					//	var codes = _steamLangCodes[i];
					//	SortedDictionary<string, LocalizedObject> table;
					//	if (languageTable.TryGetValue(codes[0], out table)) {
					//		LocalizedObject lobj;
					//		if (table.TryGetValue(nameKey, out lobj)) {
					//			var nameValue = lobj.TextValue;
					//			if (table.TryGetValue(descKey, out lobj)) {
					//				var descValue = string.Format(lobj.TextValue, param1, param2, param3);
					//				if (table.TryGetValue(itemKey, out lobj)) {
					//					var itemValue = lobj.TextValue;
					//					if (!(string.IsNullOrEmpty(nameValue) || string.IsNullOrEmpty(descValue))) {
					//						file.Append("\"name_" + codes[1] + "\": \"" + nameValue.Replace("\"", "\\\"") + "\",");
					//						file.Append("\"description_" + codes[1] + "\": \"" + string.Format("{0} (ilvl {1})\",", descValue.Replace("\"", "\\\""), ilvl));
					//						file.Append("\"display_type_" + codes[1] + "\": \"" + itemValue + "\",");
					//						english = english || (codes[0] == "en");
					//					}
					//				}
					//			}
					//		}
					//	}
					//}
					//if (!english) {
					//	// write default english keys.
					//	file.Append("\"name\": \"???" + nameKey + "???\",");
					//	file.Append("\"description\": \"" + string.Format("???{0}??? (ilvl {1})\",", descKey, ilvl));
					//	file.Append("\"display_type\": \"<Missing>\",");
					//}
					
				};
			}

			var gameManager = AssetDatabase.LoadAssetAtPath<GameManager>("Assets/Prefabs/GameManager.prefab");
			if (gameManager != null) {
				var library = gameManager.staticData.inventoryItemLibrary;
				if (library.GenerateItems()) {
					EditorUtility.SetDirty(gameManager.staticData);
				}
				try {
					var lastID = -1;

					int idStart;
					int nextID;
					LoadNextFreeID(out idStart, out nextID);

					List<int> idsToUpload = new List<int>();
					string original;

					var itemCount = idStart;
					if (library._items != null) {
						itemCount += library._items.Length;
					}
					var progress = new EditorProgressBar("Exporting items...", itemCount);

					progress.description = string.Format("{0:0000000}.txt", 0);

					using (var file = OpenItemDef(0, out original)) {
						var builder = new StringBuilder();
						builder.Append("{");
						builder.Append("\"appid\": 346930,");
						builder.Append("\"itemdefid\": 0,");
						builder.Append("\"type\": \"item\",");
						builder.Append("\"name\": \"UNUSED\",");
						builder.Append("\"tradable\": false,");
						builder.Append("\"marketable\": false,");
						builder.Append("\"commodity\": true,");
						builder.Append("\"hidden\": true,");
						builder.Append("\"store_hidden\": true");
						builder.Append("}");
						var str = builder.ToString();
						if (str != original) {
							idsToUpload.Add(0);
						}
						file.Write(str);
					}

					progress.Step(null);

					// mark items in invalid range unused...
					for (int i = 1; i < idStart; ++i) {
						progress.description = string.Format("{0:0000000}.txt", i);
						using (var file = OpenItemDef(i, out original)) {
							var builder = new StringBuilder();
							builder.Append("{");
							builder.Append("\"appid\": 346930,");
							builder.Append("\"itemdefid\": " + i + ",");
							builder.Append("\"type\": \"item\",");
							builder.Append("\"name\": \"DEPRECATED\",");
							builder.Append("\"tradable\": false,");
							builder.Append("\"marketable\": false,");
							builder.Append("\"commodity\": true,");
							builder.Append("\"hidden\": true,");
							builder.Append("\"store_hidden\": true");
							builder.Append("}");
							var str = builder.ToString();
							if (str != original) {
								idsToUpload.Add(i);
							}
							file.Write(str);
						}
						progress.Step(null);
					}

					if (library._items != null) {
						for (int i = 0; i < library._items.Length; ++i) {
							var item = library._items[i];
							if (item != null) {
								progress.description = item.name;
							}
							var iitem = item as InventoryItemClass;
							if ((iitem != null) && (iitem.ilvl2id != null) && (iitem.ilvl2id.Count > 0)) {
								WriteSteamItemDef(gameManager, idsToUpload, translateFunc, iitem, ref lastID);
							}
							progress.Step(null);
						}
					}
										
					if (lastID >= nextID) {
						SaveNextFreeID(idStart, lastID+1);
					}

					if (upload && (idsToUpload.Count > 0)) {
						UploadItemDefsToSteam(idsToUpload);
					} else {
						EditorUtility.DisplayDialog("Export Steam Inventory", "Export complete, no items changed.", "OK");
					}

				} catch (Exception e) {
					Debug.LogException(e);
				}
			}
		}

		static CoRunIEnumerator _coRunUpload;

		static void EditorUpdateUpload() {
			var remove = false;
			try {
				remove = !_coRunUpload.Step();
			} catch (Exception e) {
				Debug.LogException(e);
				remove = true;
			} finally {
				if (remove) {
					_coRunUpload = null;
					EditorApplication.update -= EditorUpdateUpload;
				}
			}
		}

		static void UploadItemDefsToSteam(List<int> idsToUpload) {
			_coRunUpload = new CoRunIEnumerator(CoUploadItemDefsToSteam(idsToUpload));
			EditorApplication.update += EditorUpdateUpload;
		}

		const uint MAX_STEAM_CALL_RATE = 225/5;
		const uint MIN_STEAM_CALL_TIME = 1000/MAX_STEAM_CALL_RATE;
		const int BATCH_SIZE = 250;

		static IEnumerator CoUploadItemDefsToSteam(List<int> idsToUpload) {

			var progress = new EditorProgressBar("Uploading ItemDefs to Steam...", (idsToUpload.Count + BATCH_SIZE - 1) / BATCH_SIZE);

			for (int i = 0; i < idsToUpload.Count; i += BATCH_SIZE) {

				List<string> itemdefs = new List<string>();
				for (int k = 0; (k < BATCH_SIZE) && ((k+i) < idsToUpload.Count); ++k) {
					itemdefs.Add(ReadItemDef(idsToUpload[k+i]));
				}

				var startTime = Utils.ReadMilliseconds();

				var response = Online.SteamWebAPI.SteamInventoryUpdateItemDefs.Execute(itemdefs);
				yield return response.Wait();

				if (!response.response) {
					progress.Close();
					for (int k = 0; (k < BATCH_SIZE) && ((k+i) < idsToUpload.Count); ++k) {
						File.Delete(GetItemDefPath(idsToUpload[k+i]));
					}
					
					EditorUtility.DisplayDialog("ERROR: Export Steam Inventory", "Inventory export failed", "OK");
					yield break;
				}

				while (true) {
					var endTime = Utils.ReadMilliseconds();
					var deltaTime = endTime-startTime;
					if (deltaTime >= MIN_STEAM_CALL_TIME) {
						break;
					}
					yield return null;
				}

				progress.Step(null);
			}

			EditorUtility.DisplayDialog("Export Steam Inventory", "Export complete, uploaded " + idsToUpload.Count + " items.", "OK");
		}

		static void WriteSteamItemDef(GameManager gm, List<int> idsToUpload, Action<StringBuilder, string, string, string, string, int, float, float, float> translateFunc, InventoryItemClass item, ref int lastID) {
			var ilvl2id = item.ilvl2id;
			var range = item.generatedItems.ilvlRange;
			string socket = "Default";

			{
				var socketItem = item as InventorySocketItemClass;
				if (socketItem != null) {
					socket = socketItem.socket.ToString();
				} else {
					var grantItem = item as InventoryGrantAbilityItemClass;
					if (grantItem != null) {
						socket = grantItem.itemType.ToString();
					}
				}
			}

			foreach (var pair in ilvl2id) {
				lastID = Mathf.Max(lastID, pair.Value);

				string original;

				using (var file = OpenItemDef(pair.Value, out original)) {
					var builder = new StringBuilder();

					builder.Append("{");

					builder.Append("\"appid\": 346930,");
					builder.Append("\"itemdefid\": " + pair.Value + ",");
					builder.Append("\"type\": \"item\",");

					if (item.deprecated || (pair.Key < range.x) || (pair.Key > range.y)) {
						builder.Append("\"name\": \"DEPRECATED\",");
						builder.Append("\"tradable\": false,");
						builder.Append("\"marketable\": false,");
						builder.Append("\"commodity\": true,");
						builder.Append("\"hidden\": true,");
						builder.Append("\"store_hidden\": true");
					} else {
						var spellPower = gm.staticData.xpTable.GetSpellPower(pair.Key);
						translateFunc(builder, item.nameKey, item.descriptionKey, item.name, socket, pair.Key, item.dontScaleDescriptionParam ? item.descParam1 : Mathf.FloorToInt(item.descParam1*spellPower), item.dontScaleDescriptionParam ? item.descParam2 : Mathf.FloorToInt(item.descParam2*spellPower), item.descParam3);

						builder.Append("\"name_color\": \"" + ColorUtility.ToHtmlStringRGB(Color.white) + "\",");
						builder.Append("\"background_color\": \"" + ColorUtility.ToHtmlStringRGB(new Color32(31, 31, 31, 255)) + "\",");
						builder.Append("\"item_slot\": \"" + socket + "\",");
						builder.Append("\"item_quality\": " + ((int)item.quality).ToString() + ",");
						builder.Append("\"icon_url\": \"http://s3.amazonaws.com/deadhold-inventory/icons/" + item.steamIconName + "\",");
						builder.Append("\"icon_url_large\": \"http://s3.amazonaws.com/deadhold-inventory/icons/" + item.steamIconName + "\",");
						if (item.price != EInventoryItemPrice.None) {
							builder.Append("\t\t\"price_category\": \"1;" + item.price.ToString() + "\",");
						}
						if (item.autoGrant) {
							builder.Append("\"promo\": \"owns:346930\",");
						}
						builder.Append("\"tradable\": " + item.tradable.ToString().ToLower() + ",");
						builder.Append("\"marketable\": " + item.marketable.ToString().ToLower() + ",");
						builder.Append("\"commodity\": " + item.commodity.ToString().ToLower() + ",");
						builder.Append("\"hidden\": " + (item.hidden || item.deprecated).ToString().ToLower() + ",");
						builder.Append("\"store_hidden\": " + ((item.price == EInventoryItemPrice.None) || item.hidden || item.deprecated).ToString().ToLower());

					}

					builder.Append("}"); // don't flush line ending here
					var str = builder.ToString();
					if (str != original) {
						idsToUpload.Add(pair.Value);
					}
					file.Write(str);
				}
			}
		}

		static string GetItemDefPath(int id) {
			return string.Format("{0}/SteamInventory/ItemDefs/{1:0000000}.txt", Utils.projectRootDirectory, id);
		}

		static string ReadItemDef(int id) {
			using (var reader = new StreamReader(GetItemDefPath(id), true)) {
				return reader.ReadToEnd();
			}
		}

		static StreamWriter OpenItemDef(int id, out string original) {

			try {
				original = ReadItemDef(id);
			} catch (Exception) {
				original = string.Empty;
			}

			return new StreamWriter(GetItemDefPath(id), false, new UTF8Encoding(true));
		}
#endif
	}
}
 
 